<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>/wtf</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden}
    canvas{display:block;width:100vw;height:100vh}
    /* remove selection/highlight */
    html,body,canvas{user-select:none;-webkit-user-select:none;-ms-user-select:none}
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <script>
    // Pure-visual generative scene â€” no UI, no text.
    (()=>{
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');
      let W, H, DPR = Math.max(1, window.devicePixelRatio || 1);
      function resize(){ W = innerWidth; H = innerHeight; canvas.width = Math.floor(W*DPR); canvas.height = Math.floor(H*DPR); canvas.style.width = W+'px'; canvas.style.height = H+'px'; ctx.setTransform(DPR,0,0,DPR,0,0); }
      addEventListener('resize', resize, {passive:true}); resize();

      // particles
      const N = Math.floor(Math.min(1400, Math.max(220, (W*H)/7000)));
      const particles = [];

      // seed random
      const rng = (s=>{let t=s; return ()=>{t+=0x6D2B79F5; let r=Math.imul(t^t>>>15,1|t); r ^= r + Math.imul(r^r>>>7,61|r); return ((r ^ r>>>14) >>> 0) / 4294967296;}})(Math.floor(Math.random()*1e9));

      for(let i=0;i<N;i++){
        particles.push({
          x: rng()*W,
          y: rng()*H,
          vx: (rng()-0.5)*0.6,
          vy: (rng()-0.5)*0.6,
          life: 50 + rng()*250,
          hue: Math.floor(rng()*360)
        });
      }

      // field parameters
      let t0 = 0;
      function field(x,y,t){
        // layered sin/cos flows for organic motion
        const s = 0.0009;
        const v1 = Math.sin((x+y)*s + t*0.0006);
        const v2 = Math.cos((x*0.7 - y*1.2)*s - t*0.0008);
        const v3 = Math.sin((x*1.6 + y*0.3)*s + Math.cos(t*0.0004));
        return (v1*0.6 + v2*0.4 + v3*0.3);
      }

      // draw loop
      let last = performance.now();
      function step(now){
        const dt = Math.min(40, now - last);
        last = now;
        t0 += dt;

        // fade with slight transparency to keep trails
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(3,3,7,0.12)';
        ctx.fillRect(0,0,W,H);

        // subtle vignette via radial gradient overlay
        const g = ctx.createRadialGradient(W*0.5, H*0.5, Math.min(W,H)*0.2, W*0.5, H*0.5, Math.max(W,H));
        g.addColorStop(0, 'rgba(0,0,0,0)');
        g.addColorStop(1, 'rgba(0,0,0,0.25)');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,W,H);

        ctx.globalCompositeOperation = 'lighter';

        for(let p of particles){
          // sample field and rotate velocity towards it
          const f = field(p.x, p.y, t0);
          // curl-like turn
          const angle = f * Math.PI * 2 + Math.sin((p.x+p.y+t0*0.001)/200)*0.8;
          const speed = 0.12 + (Math.abs(f))*0.9 + (Math.sin(t0*0.001 + p.hue) + 1)*0.01;
          p.vx += Math.cos(angle) * speed * 0.08;
          p.vy += Math.sin(angle) * speed * 0.08;

          // damping
          p.vx *= 0.985; p.vy *= 0.985;

          p.x += p.vx * (dt*0.06);
          p.y += p.vy * (dt*0.06);

          // wrap
          if(p.x < -50) p.x = W+50; if(p.x > W+50) p.x = -50;
          if(p.y < -50) p.y = H+50; if(p.y > H+50) p.y = -50;

          // life-driven color shift
          p.life -= dt*0.02;
          if(p.life <= 0){
            p.x = rng()*W; p.y = rng()*H; p.vx = (rng()-0.5)*0.6; p.vy = (rng()-0.5)*0.6; p.life = 120 + rng()*300; p.hue = Math.floor(rng()*360);
          }

          // render glow
          const hue = (p.hue + t0*0.008) % 360;
          const size = 1 + (1.2 - Math.min(1.2, Math.hypot(p.vx,p.vy)*6)) * 5;

          const grd = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size*6);
          grd.addColorStop(0, `hsla(${hue},90%,60%,0.9)`);
          grd.addColorStop(0.2, `hsla(${(hue+30)%360},80%,55%,0.35)`);
          grd.addColorStop(0.6, `hsla(${(hue+80)%360},70%,45%,0.06)`);
          grd.addColorStop(1, 'rgba(0,0,0,0)');

          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(p.x, p.y, size*6, 0, Math.PI*2);
          ctx.fill();

          // sharp core
          ctx.globalCompositeOperation = 'source-over';
          ctx.fillStyle = `hsla(${hue},95%,55%,${0.18 + Math.min(0.6, Math.hypot(p.vx,p.vy))})`;
          ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(0.6, size*0.6), 0, Math.PI*2); ctx.fill();

          ctx.globalCompositeOperation = 'lighter';
        }

        // occasional larger blooms
        if(Math.random() < 0.008){
          const bx = rng()*W, by = rng()*H, r = 30 + rng()*120, hue = Math.floor(rng()*360);
          const gg = ctx.createRadialGradient(bx,by,0,bx,by,r);
          gg.addColorStop(0, `hsla(${hue},95%,65%,0.28)`);
          gg.addColorStop(0.5, `hsla(${(hue+50)%360},85%,55%,0.08)`);
          gg.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = gg; ctx.beginPath(); ctx.arc(bx,by,r,0,Math.PI*2); ctx.fill();
        }

        requestAnimationFrame(step);
      }

      // initial clear
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
      requestAnimationFrame(step);

      // subtle wake on interaction (no UI)
      function spark(x,y){
        for(let i=0;i<40;i++){
          particles.push({x,y,vx:(Math.random()-0.5)*6,vy:(Math.random()-0.5)*6,life:80+Math.random()*160,hue:Math.floor(Math.random()*360)});
        }
        // trim
        while(particles.length > N) particles.shift();
      }
      addEventListener('pointerdown', (e)=>{ spark(e.clientX, e.clientY); }, {passive:true});
      addEventListener('touchstart', (e)=>{ const t=e.touches[0]; if(t) spark(t.clientX, t.clientY); }, {passive:true});

      // gentle auto-resize particle count on orientation change
      addEventListener('orientationchange', ()=>{ setTimeout(()=>{ resize(); },250); }, {passive:true});
    })();
  </script>
</body>
</html>
