<html>
    <head>
        <meta charset="utf-8">
        <title>WebGL Ray Tracer</title>
        <script id="vshader" type="x-shader/x-vertex">
            attribute vec2 vPosition;
            varying vec2 fPosition;

            void main() {
                fPosition = vPosition;
                gl_Position = vec4(vPosition, 0.0, 1.0);
            }
        </script>
        <script id="fshader" type="x-shader/x-fragment">
            precision highp float;
            varying vec2 fPosition;

            const int maxObjs = 20;
            const int maxReflections = 200;

            uniform float alpha;
            const float reflections = 100.0;
            const float focalLength = 2.0;

            struct Sphere {
                vec3 center;
                float radius;
                vec3 color;
                float reflectivity;
            };

            struct Plane {
                vec3 point;
                vec3 normal;
                vec3 color;
                float reflectivity;
            };

            struct Ray {
                vec3 origin;
                vec3 direction;
                float intensity;
            };

            struct Light {
                vec3 position;
                vec3 ambient, diffuse, specular;
            };

            struct RayTracerOutput {
                Ray reflectedRay;
                vec3 color;
            };

            Light light;
            Sphere spheres[maxObjs];
            Plane planes[maxObjs];
            int numSpheres = 3, numPlanes = 1;

            const float PI = 3.14159265358979323846264;

            mat4 rotateZ(float theta) {
                float c = cos(theta);
                float s = sin(theta);
                return mat4(
                    c, s, 0.0, 0.0,
                    -s, c, 0.0, 0.0,
                    0.0, 0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0, 1.0
                );
            }

            mat4 translate(vec3 offset) {
                return mat4(
                    1.0, 0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    0.0, 0.0, 1.0, 0.0,
                    offset.x, offset.y, offset.z, 1.0
                );
            }

            void init() {
                light.ambient = vec3(0.2, 0.2, 0.2);
                light.diffuse = vec3(0.8, 0.8, 0.8);
                light.specular = vec3(0.95, 0.95, 0.95);
                light.position = vec3(0.0, 0.0, 0.6);

                spheres[0].color = vec3(0.0, 0.0, 1.0);
                spheres[0].reflectivity = 0.7;
                spheres[0].center = vec3(0.0, 0.5, 0.0);
                spheres[0].radius = 0.25;

                spheres[1].color = vec3(0.0, 1.0, 0.0);
                spheres[1].reflectivity = 0.7;
                spheres[1].center = vec3(0.5, -0.5, 0.0);
                spheres[1].radius = 0.25;

                spheres[2].color = vec3(1.0, 0.0, 0.0);
                spheres[2].reflectivity = 0.7;
                spheres[2].center = vec3(-0.5, -0.5, 0.0);
                spheres[2].radius = 0.25;

                mat4 rotMat = rotateZ(alpha * 2.0 * PI);

                planes[0].color = vec3(0.4, 0.4, 0.4);
                planes[0].reflectivity = 0.3;
                planes[0].point = (rotMat * vec4(2.5, 0.0, -1.0, 1.0)).xyz;
                planes[0].normal = normalize(-planes[0].point);
            }

            // Checks if the specified ray intersects the specified sphere
            float checkIntersectSphere(Sphere sphere, Ray ray) {
                vec3 sphereCenter = sphere.center;
                float radius = sphere.radius;
                vec3 cameraSource = ray.origin;
                vec3 cameraDirection = ray.direction;

                vec3 distanceFromCenter = (cameraSource - sphereCenter);
                float B = 2.0 * dot(cameraDirection, distanceFromCenter);
                float C = dot(distanceFromCenter, distanceFromCenter) - pow(radius, 2.0);
                float delta = pow(B, 2.0) - 4.0 * C;
                float t = 0.0;
                if (delta > 0.0) {
                    float sqRoot = sqrt(delta);
                    float t1 = (-B + sqRoot) / 2.0;
                    float t2 = (-B - sqRoot) / 2.0;
                    t = min(t1, t2);
                }
                if (delta == 0.0) {
                    t = -B / 2.0;
                }

                return t;
            }

            // Checks if the specified ray intersects the specified plane
            float checkIntersectPlane(Plane plane, Ray ray) {
                float numerator = dot(plane.point - ray.origin, plane.normal);
                float denominator = dot(ray.direction, plane.normal);
                if (denominator == 0.0) return 0.0;
                return numerator / denominator;
            }

            // Checks to see if a ray intersects a world object before the light
            // Used for the shadow ray
            bool intersectsBeforeLight(Ray ray) {
                float distanceToLight = distance(ray.origin, light.position);

                // Spheres
                for (int i = 0; i < maxObjs; i++) {
                    if (i >= numSpheres) break;
                    float t = checkIntersectSphere(spheres[i], ray);
                    if (t > 0.0 && t < distanceToLight) {
                        return true;
                    }
                }

                // Planes
                for (int i = 0; i < maxObjs; i++) {
                    if (i >= numPlanes) break;
                    float t = checkIntersectPlane(planes[i], ray);
                    if (t > 0.0 && t < distanceToLight) {
                        return true;
                    }
                }

                return false;
            }


            // Traces a ray through the world
            // Returns a reflection ray and a calculated color
            RayTracerOutput traceRay(Ray ray) {

                // Conduct intersection testing
                float minT = 100000.0;
                int typeToShow = 0; // 0 for nothing, 1 for sphere, 2 for plane
                Sphere sphere;
                Plane plane;

                // Sphere intersection testing
                for (int i = 0; i < maxObjs; i++) {
                    if (i >= numSpheres) break;
                    float t = checkIntersectSphere(spheres[i], ray);
                    if (t > 0.0 && t < minT) {
                        minT = t;
                        sphere = spheres[i];
                        typeToShow = 1;
                    }
                }

                // Plane intersection testing
                for (int i = 0; i < maxObjs; i++) {
                    if (i >= numPlanes) break;
                    float t = checkIntersectPlane(planes[i], ray);
                    if (t > 0.0 && t < minT) {
                        minT = t;
                        plane = planes[i];
                        typeToShow = 2;
                    }
                }

                // Calculate ray color & reflection
                RayTracerOutput rayTracer;
                vec3 color = vec3(0.0, 0.0, 0.0);
                if (typeToShow > 0) {

                    // Get variables from the intersected object
                    vec3 surfacePoint = ray.origin + (minT * ray.direction);
                    vec3 surfaceNormal;
                    vec3 objColor;
                    float reflectivity;
                    if (typeToShow == 1) {
                        surfaceNormal = normalize(surfacePoint - sphere.center);
                        objColor = sphere.color;
                        reflectivity = sphere.reflectivity;
                    } else if (typeToShow == 2) {
                        surfaceNormal = plane.normal;
                        objColor = plane.color;
                        reflectivity = plane.reflectivity;
                    }

                    // Ambient light
                    color += light.ambient * objColor;

                    // Shadow check
                    // Only show diffuse + specular if we are not in shadow
                    vec3 L = normalize(light.position - surfacePoint);
                    Ray shadowRay;
                    shadowRay.origin = surfacePoint + 0.00001 * L;
                    shadowRay.direction = L;
                    if (!intersectsBeforeLight(shadowRay)) {
                        vec3 N = surfaceNormal;

                        // Diffuse light
                        color += light.diffuse * objColor * max(0.0, dot(L, N));

                        // Specular light
                        float shininess = 20.0;
                        vec3 R = reflect(-L, N);
                        vec3 C = normalize(ray.origin - surfacePoint);
                        float specular = pow(max(dot(R, C), 0.0), shininess);
                        color += light.specular * specular * reflectivity;
                    }

                    // Reflection ray
                    Ray reflectionRay;
                    vec3 reflection = reflect(ray.direction, surfaceNormal);
                    reflectionRay.origin = surfacePoint + 0.00001 * reflection;
                    reflectionRay.direction = reflection;
                    reflectionRay.intensity = ray.intensity * reflectivity;
                    rayTracer.reflectedRay = reflectionRay;
                }
                rayTracer.color = color * ray.intensity;

                return rayTracer;
            }


            void main() {
                init();

                // Create the first ray
                Ray currRay;
                currRay.origin = vec3(0.0, 0.0, focalLength);
                currRay.direction = normalize(vec3(fPosition, -focalLength));
                currRay.intensity = 1.0;

                // Calculate the final color
                vec3 color = vec3(0.0, 0.0, 0.0);
                for (int i = 0; i <= maxReflections; i++) {
                    if (i > int(reflections)) break;
                    RayTracerOutput rayTracer = traceRay(currRay);
                    color += rayTracer.color;
                    currRay = rayTracer.reflectedRay;
                }
                gl_FragColor = vec4(color, 1.0);
            }
        </script>
        <script>
            const names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
            var gl, program;
            const glBounds = [
                -1, 1,
                1, 1,
                -1, -1,
                1, -1,
            ];
            var alpha = 0;
            var lastFrameTime = Date.now();
            var fps = 0;

            function initShaders(gl, vertexShaderId, fragmentShaderId) {
                var vertElem = document.getElementById(vertexShaderId);
                var fragElem = document.getElementById(fragmentShaderId);

                const vertShdr = gl.createShader(gl.VERTEX_SHADER);
                const fragShdr = gl.createShader(gl.FRAGMENT_SHADER);

                gl.shaderSource(vertShdr, vertElem.text);
                gl.compileShader(vertShdr);
                gl.shaderSource(fragShdr, fragElem.text);
                gl.compileShader(fragShdr);

                var program = gl.createProgram();
                gl.attachShader(program, vertShdr);
                gl.attachShader(program, fragShdr);
                gl.linkProgram(program);
                return program;
            }

            function main() {
                const canvas = document.querySelector('canvas');

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                
                for (var ii = 0; ii < names.length; ++ii) {
                    try {
                        gl = canvas.getContext(names[ii], undefined);
                    } catch (e) { }
                        if (gl) {
                            break;
                        }
                }

                program = initShaders(gl, 'vshader', 'fshader');
                gl.useProgram(program);
                gl.viewport(0, 0, window.innerWidth, window.innerHeight);

                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                var floats = new Float32Array(glBounds.length);
                for ( var i = 0; i < glBounds.length; ++i ) {
                    floats[i] = glBounds[i];
                }
                gl.bufferData(gl.ARRAY_BUFFER, floats, gl.STATIC_DRAW);
                const pos = gl.getAttribLocation(program, 'vPosition');
                gl.enableVertexAttribArray(pos);
                gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

                requestAnimationFrame(render);

                setInterval(() => {
                    const text = `${fps.toFixed(2)} fps`;
                    document.getElementById('fps').textContent = text;
                }, 400);
            }

            function render() {
                alpha = (alpha + 0.002) % 1;
                gl.uniform1f(gl.getUniformLocation(program, 'alpha'), alpha);
                const currFrameTime = Date.now();
                fps = 1000 / (currFrameTime - lastFrameTime);
                lastFrameTime = currFrameTime;
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                requestAnimationFrame(render);
            }
        </script>
    </head>
    <body onload="main()" style="margin: 0px;">
        <div>
            <div>
                <span id="fps" style="position: absolute;color: white;"></span>
            </div>
            <canvas width="" height=""></canvas>
        </div>
    </body>
</html>
